/**
 ******************************************************************************
 * @file           : ADC.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : ADC and IR sensor management
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"
#include "serial.h"
#include "ADC.h"

typedef struct {
    uint16_t value_1;
    uint16_t value_2;
    uint16_t value_3;
} ADCValues_t;

// Private variables - hidden from other modules
IR_values current_ir_values = {0, 0, 0};
IR_values previous_ir_values = {0, 0, 0};


void delay(volatile uint32_t ms) {
    // This assumes the CPU is running at around 72 MHz
    // Adjust 8000 for more/less precise timing
    for (volatile uint32_t i = 0; i < ms * 8000; i++) {
        __NOP(); // Assembly NOP (No Operation) instruction
    }
}

// Private functions
static void enable_clocks_ADC() {
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;
}

static void initialise_board_ADC() {
    // Configure PA1, PA2, PA3 as analog inputs
    GPIOA->MODER |= (3 << (1 * 2)) | (3 << (2 * 2)) | (3 << (3 * 2));
}

void ADC_Init(void) {
    // Enable ADC1 clock
    RCC->AHBENR |= RCC_AHBENR_ADC12EN;

    // Sync ADC clock with AHB
    ADC12_COMMON->CCR |= ADC12_CCR_CKMODE_0;

    // Enable ADC voltage regulator
    ADC1->CR &= ~ADC_CR_ADVREGEN;
    ADC1->CR |= ADC_CR_ADVREGEN_0;
    for (volatile int i = 0; i < 1000; i++); // Small delay for regulator startup

    // Set single-ended input
    ADC1->CR &= ~ADC_CR_ADCALDIF;

    // Calibrate
    ADC1->CR |= ADC_CR_ADCAL;
    while (ADC1->CR & ADC_CR_ADCAL);

    // Configure sampling time (optional – can uncomment and tune)
    // ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP2_Pos); // CH2
    // ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP3_Pos); // CH3
    // ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP4_Pos); // CH4

    // Set conversion sequence: CH2 → CH3 → CH4
    ADC1->SQR1 = 0;
    ADC1->SQR1 |= (0x02 << ADC_SQR1_SQ1_Pos); // CH2
    ADC1->SQR1 |= (0x03 << ADC_SQR1_SQ2_Pos); // CH3
    ADC1->SQR1 |= (0x04 << ADC_SQR1_SQ3_Pos); // CH4
    ADC1->SQR1 |= (2 << ADC_SQR1_L_Pos);      // L = 2 → 3 conversions

    // Single-shot mode
    ADC1->CFGR &= ~ADC_CFGR_CONT;

    // Enable ADC
    ADC1->CR |= ADC_CR_ADEN;
    while (!(ADC1->ISR & ADC_ISR_ADRDY));
}

ADCValues_t ADC_Read(void) {
    ADCValues_t result;

    // Start conversion
    ADC1->CR |= ADC_CR_ADSTART;

    // Wait and read channel 1
    while (!(ADC1->ISR & ADC_ISR_EOC));
    result.value_1 = ADC1->DR;

    // Wait and read channel 2
    while (!(ADC1->ISR & ADC_ISR_EOC));
    result.value_2 = ADC1->DR;

    // Wait and read channel 3
    while (!(ADC1->ISR & ADC_ISR_EOC));
    result.value_3 = ADC1->DR;

    // Clear End of Sequence
    ADC1->ISR |= ADC_ISR_EOS;

    return result;
}

// Latching ADC_threshold function
static void ADC_threshold(uint16_t ADC_value, int8_t *IR_value) {
    if (ADC_value >= 1250) {
        *IR_value = 1;  // Set to 1 when threshold is reached
    } else {
        *IR_value = 0;
    }
}

// Public function implementations

void ADC_Initialize(void) {
    enable_clocks_ADC();
    initialise_board_ADC();
    ADC_Init();

    // Initialize IR values
    current_ir_values.IR1 = 0;
    current_ir_values.IR2 = 0;
    current_ir_values.IR3 = 0;
    previous_ir_values.IR1 = 0;
    previous_ir_values.IR2 = 0;
    previous_ir_values.IR3 = 0;


}

IR_values ADC_ReadIRSensors(void) {


    // Otherwise, read actual ADC values
    ADCValues_t adc_values;
    char buffer[64];

    // Read ADC values
    adc_values = ADC_Read();

    // Debug output (optional)
    sprintf(buffer, "CH2: %d, CH3: %d, CH4: %d\r\n",
            adc_values.value_1, //PA1
            adc_values.value_2, //PA2
            adc_values.value_3); //PA3

    // Apply thresholding with latching behavior
    ADC_threshold(adc_values.value_1, &current_ir_values.IR1);
    ADC_threshold(adc_values.value_2, &current_ir_values.IR2);
    ADC_threshold(adc_values.value_3, &current_ir_values.IR3);

    return current_ir_values;
}

int8_t ADC_CheckIRChanges(void) {
    // Store previous values before reading new ones
    IR_values temp_previous = current_ir_values;

    // Update current values (respects simulation mode)
    current_ir_values = ADC_ReadIRSensors();

    // Check for changes
    if (current_ir_values.IR1 != temp_previous.IR1 ||
        current_ir_values.IR2 != temp_previous.IR2 ||
        current_ir_values.IR3 != temp_previous.IR3) {

        // Update previous values
        previous_ir_values = temp_previous;
        return 1; // Change detected
    }
    return 0; // No change
}

void ADC_ResetIRSensors(void) {
    current_ir_values.IR1 = 0;
    current_ir_values.IR2 = 0;
    current_ir_values.IR3 = 0;
    previous_ir_values.IR1 = 0;
    previous_ir_values.IR2 = 0;
    previous_ir_values.IR3 = 0;
}

IR_values ADC_GetCurrentIRValues(void) {
    return current_ir_values;
}

// Function to manually set IR values (for button simulation)
void ADC_SetIRValues(IR_values new_values) {
    current_ir_values = new_values;
}


