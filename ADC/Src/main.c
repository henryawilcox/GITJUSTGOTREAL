/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"
#include "serial.h"

typedef struct {
    uint16_t value_1;
    uint16_t value_2;
    uint16_t value_3;
} ADCValues_t;



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void delay(volatile uint32_t ms) {
    // This assumes the CPU is running at around 72 MHz
    // Adjust 8000 for more/less precise timing
    for (volatile uint32_t i = 0; i < ms * 8000; i++) {
        __NOP(); // Assembly NOP (No Operation) instruction
    }
}


// enable the clocks for desired peripherals (GPIOA, C and E)
void enable_clocks() {
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;
}

// initialise the discovery board I/O (just outputs: inputs are selected by default)
void initialise_board() {

	// get a pointer to the second half word of the MODER register (for outputs pe8-15)
	uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
	*led_output_registers = 0x5555;
	GPIOA->MODER |= (3 << (1 * 2)) | (3 << (2 * 2)) | (3 << (3 * 2));
}


void ADC_Init(void) {
    // Enable ADC1 clock
    RCC->AHBENR |= RCC_AHBENR_ADC12EN;

    // Sync ADC clock with AHB
    ADC12_COMMON->CCR |= ADC12_CCR_CKMODE_0;

    // Enable ADC voltage regulator
    ADC1->CR &= ~ADC_CR_ADVREGEN;
    ADC1->CR |= ADC_CR_ADVREGEN_0;
    for (volatile int i = 0; i < 1000; i++); // Small delay for regulator startup

    // Set single-ended input
    ADC1->CR &= ~ADC_CR_ADCALDIF;

    // Calibrate
    ADC1->CR |= ADC_CR_ADCAL;
    while (ADC1->CR & ADC_CR_ADCAL);

    // Configure sampling time (optional – can uncomment and tune)
    // ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP2_Pos); // CH2
    // ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP3_Pos); // CH3
    // ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP4_Pos); // CH4

    // Set conversion sequence: CH2 → CH3 → CH4
    ADC1->SQR1 = 0;
    ADC1->SQR1 |= (0x02 << ADC_SQR1_SQ1_Pos); // CH2
    ADC1->SQR1 |= (0x03 << ADC_SQR1_SQ2_Pos); // CH3
    ADC1->SQR1 |= (0x04 << ADC_SQR1_SQ3_Pos); // CH4
    ADC1->SQR1 |= (2 << ADC_SQR1_L_Pos);      // L = 2 → 3 conversions

    // Single-shot mode
    ADC1->CFGR &= ~ADC_CFGR_CONT;

    // Enable ADC
    ADC1->CR |= ADC_CR_ADEN;
    while (!(ADC1->ISR & ADC_ISR_ADRDY));
}

ADCValues_t ADC_Read(void) {
    ADCValues_t result;

    // Start conversion
    ADC1->CR |= ADC_CR_ADSTART;

    // Wait and read channel 1
    while (!(ADC1->ISR & ADC_ISR_EOC));
    result.value_1 = ADC1->DR;

    // Wait and read channel 2
    while (!(ADC1->ISR & ADC_ISR_EOC));
    result.value_2 = ADC1->DR;

    // Wait and read channel 3
    while (!(ADC1->ISR & ADC_ISR_EOC));
    result.value_3 = ADC1->DR;

    // Clear End of Sequence
    ADC1->ISR |= ADC_ISR_EOS;

    return result;
}



void SingleReadMultiChannelADC() {

	// get a pointer to the location of the LEDs
	// This points to the higher byte of GPIOE->ODR (e.g., PE8-PE15 if GPIOE->ODR is 16-bit)
	uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;
	uint8_t buffer1[64] = "This is a string !\r\n";



	// enable the clock for ADC1
	RCC->AHBENR |= RCC_AHBENR_ADC12EN;

	// set to synchronise the ADC with the clock
	ADC12_COMMON->CCR |= ADC12_CCR_CKMODE_0;

	// ADEN must be = 0 for configuration (is the default)
	ADC1->CR &= ~ADC_CR_ADVREGEN; // clear voltage regulator enable
	ADC1->CR |= ADC_CR_ADVREGEN_0; // set ADVREGEN TO 01 (enable)
	// Delay for ADC voltage regulator startup might be needed here, depending on MCU.
	ADC1->CR &= ~ADC_CR_ADCALDIF; // clear bit to enable Single-ended-input

	// calibrate the ADC (self calibration routine)
	ADC1->CR |= ADC_CR_ADCAL;
	while((ADC1->CR & ADC_CR_ADCAL) == ADC_CR_ADCAL); // Waiting for the calibration to finish


 	// can change the sampling time (longer is more accurate)
	// Example: Set longest sampling time for channels 2, 3, and 4
	// Assuming channels to read are 2, 3, and 4.
	// SMPR1 controls channels 0-9.
	// ADC_SMPR1_SMP2_Pos refers to channel 2, ADC_SMPR1_SMP3_Pos to channel 3, etc.
	//ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP2_Pos); // Max sampling time for ADC Channel 2
	//ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP3_Pos); // Max sampling time for ADC Channel 3
	//ADC1->SMPR1 |= (7U << ADC_SMPR1_SMP4_Pos); // Max sampling time for ADC Channel 4 (new)


	// We want to read from three channels each sequence
	//  the first channel goes in SQ1
	//  the second channel goes in SQ2
	//  the third channel goes in SQ3
	//  the number of channels to read = 3, so the L value is 2 (3-1)
	ADC1->SQR1 = 0; // Clear previous sequence
	// Let's assume we read Channel 2, then Channel 3, then Channel 4
	// The channel numbers (e.g., 0x02 for CH2) depend on your MCU's ADC channel mapping.
	ADC1->SQR1 |= (0x02 << ADC_SQR1_SQ1_Pos); // 1st conversion: ADC Channel 2
	ADC1->SQR1 |= (0x03 << ADC_SQR1_SQ2_Pos); // 2nd conversion: ADC Channel 3
	ADC1->SQR1 |= (0x04 << ADC_SQR1_SQ3_Pos); // 3rd conversion: ADC Channel 4 (example for the third channel)
	ADC1->SQR1 |= (4 << ADC_SQR1_L_Pos); // L = 2 for 3 channels in sequence

	// single shot mode (one sequence per ADSTART)
	ADC1->CFGR &= ~ADC_CFGR_CONT;

	// Enable the ADC
	ADC1->CR |= ADC_CR_ADEN;

	// Wait for the ADC to be ready.
	// It's generally better to wait for the ADRDY flag: while(!(ADC1->ISR & ADC_ISR_ADRDY));
	while (!(ADC1->ISR & ADC_ISR_ADRDY)); // Original wait condition, ensure it implies ADRDY or is sufficient

	uint16_t value_1 = 0;
	uint16_t value_2 = 0;
	uint16_t value_3 = 0; // Variable for the third channel

	//uint8_t display_scale_1 = 0;
	//uint8_t display_scale_2 = 0;
	//uint8_t display_scale_3 = 0; // Scaled value for the third channel for LED display

    /* Loop forever */
	for(;;) {

		// request the ADC conversion sequence to start
		ADC1->CR |= ADC_CR_ADSTART;

		// Wait for the end of the first conversion
		while (!(ADC1->ISR & ADC_ISR_EOC));
		// read the first value (reading DR also clears EOC)
		value_1 = ADC1->DR;



		//Wait for the end of the second conversion
		while(!(ADC1->ISR & ADC_ISR_EOC));
		// read the second value
		value_2 = ADC1->DR;

		// Wait for the end of the third conversion
		while(!(ADC1->ISR & ADC_ISR_EOC));
		// read the third value
		value_3 = ADC1->DR;

		// After all conversions in the sequence are done, EOS flag is set.
		// Reset the End Of Sequence flag (optional if not explicitly checked, but good practice)
		ADC1->ISR |= ADC_ISR_EOS;
		sprintf(buffer1, "yasCH2: %d, CH3: %d, CH4: %d\r\n", value_1, value_2, value_3);
		SerialOutputString(buffer1, &USART1_PORT);

		// ADC full range is 12 bits (0xFFF maximum = 4095)
		// To display 3 channels on 8 LEDs, we'll use 2 LEDs per channel.
		// So, scale each value to 0 or 1.
		// (0xFFF / 2) = 2047.5. Integer division will be 2047.
		// value / 2048 effectively gives 0 for values < 2048, and 1 for values >= 2048 (approx).
	/*	const uint16_t half_range = (0xFFF + 1) / 2; // = 2048

		display_scale_1 = value_1 / half_range;
		if (display_scale_1 > 1) {
			display_scale_1 = 1;
		}


		display_scale_2 = value_2 / half_range;
		if (display_scale_2 > 1) {
			display_scale_2 = 1;
		}

		display_scale_3 = value_3 / half_range;
		if (display_scale_3 > 1) {
			display_scale_3 = 1;
		}

		// Display the state of the three channels using 6 LEDs (2 per channel)
		// Channel 1: LEDs 0-1 (controlled by *led_register bits 0 and 1 via `1 << display_scale_1`)
		// Channel 2: LEDs 2-3 (controlled by *led_register bits 2 and 3 via `1 << (display_scale_2 + 2)`)
		// Channel 3: LEDs 4-5 (controlled by *led_register bits 4 and 5 via `1 << (display_scale_3 + 4)`)
		// This lights one of the two designated LEDs for each channel based on its scaled value (0 or 1).
		*led_register = (1 << display_scale_1) | (1 << (display_scale_2 + 2)) | (1 << (display_scale_3 + 4));
*/
		// Optional: Add a small delay here if needed for visibility or timing
		delay(50);
	}
}


int main(void)
{
	enable_clocks();
	initialise_board();
	SerialInitialise(BAUD_115200, &USART1_PORT, &finished_transmission);


    //StartADC1_MultiChannel_Continuous();
   // Loop_ReadAndPrint_ADC();

	// check if the button is pressed, determine which mode
	//  to enter.

	char buffer[64];
	    ADCValues_t adc_values;

	    ADC_Init(); // Set up the ADC once

	    while (1) {
	        adc_values = ADC_Read(); // Get values

	        sprintf(buffer, "CH2: %d, CH3: %d, CH4: %d\r\n",
	                adc_values.value_1,
	                adc_values.value_2,
	                adc_values.value_3);
	        SerialOutputString(buffer, &USART1_PORT);

	        delay(10);
	    }

	//SingleReadMultiChannelADC();
}
